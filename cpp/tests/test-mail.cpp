/*
 * Copyright (c) 2007-2010 Digital Bazaar, Inc. All rights reserved.
 */
#include "monarch/data/json/JsonWriter.h"
#include "monarch/io/ByteArrayInputStream.h"
#include "monarch/mail/SmtpClient.h"
#include "monarch/mail/MailTemplateParser.h"
#include "monarch/mail/MailSpool.h"
#include "monarch/net/Url.h"
#include "monarch/test/Test.h"
#include "monarch/test/Tester.h"
#include "monarch/test/TestRunner.h"
#include "monarch/util/StringTools.h"

using namespace std;
using namespace monarch::io;
using namespace monarch::net;
using namespace monarch::test;
using namespace monarch::rt;
using namespace monarch::util;

#define VALID_SMTP_SERVER "smtp://mail.digitalbazaar.com:25"

void runSmtpClientTest(TestRunner& tr)
{
   tr.test("SmtpClient");

   // set url of mail server
   Url url(VALID_SMTP_SERVER);

   // set mail
   monarch::mail::Mail mail;
   mail.setSender("testuser@bitmunk.com");
   mail.addTo("support@bitmunk.com");
   mail.addCc("support@bitmunk.com");
   mail.setSubject("This is an autogenerated unit test email");
   mail.setBody("This is the test body");

   //mail.setHeader("MIME-Version", "1.0");
   //mail.setHeader("Content-Transfer-Encoding", "base64");

   // send mail
   monarch::mail::SmtpClient c;
   c.sendMail(&url, &mail);

   tr.passIfNoException();
}

void runMimeTest(TestRunner& tr)
{
   tr.group("Mime");

   tr.test("simple base64");
   {
      // set url of mail server
      Url url(VALID_SMTP_SERVER);

      // set mail
      monarch::mail::Mail mail;
      mail.setSender("testuser@bitmunk.com");
      mail.addTo("support@bitmunk.com");
      mail.setSubject("This is an autogenerated unit test MIME email");
      string body =
         "This is a body that is intended to test really long lines. A body "
         "containing a line that is over 1000 characters is not permitted when "
         "using SMTP unless the body is transfer-encoded. This particular "
         "body should be transfer-encoded using base64. This body has no line "
         "breaks whatsoever and is more than 1000 characters long. It ends with "
         "a whole bunch of the letter Z's. Like it's sleeping. Here come the "
         "Z's ... there are 1000 of them: ";
      body.append(1000, 'Z');
      body.append(". Thus ends the Z's and this body.");

      mail.setBody(body.c_str());

      // include mime header and content-transfer-encoding header to ensure
      // proper encoding and delivery
      mail.setHeader("MIME-Version", "1.0");
      mail.setHeader("Content-Transfer-Encoding", "base64");

      // send mail
      monarch::mail::SmtpClient c;
      c.sendMail(&url, &mail);
   }
   tr.passIfNoException();

   tr.test("template base64");
   {
      // create mail template
      const char* tpl =
         "MIME-Version: 1.0\r\n"
         "Content-Transfer-Encoding: base64\r\n"
         "Subject: This is an autogenerated unit test templated MIME email\r\n"
         "From: testuser@bitmunk.com\r\n"
         "To: support@bitmunk.com\r\n"
         "\r\n"
         "{body}";

      // create template parser
      monarch::mail::MailTemplateParser parser;

      // create input stream
      ByteArrayInputStream bais(tpl, strlen(tpl));

      // create variables
      DynamicObject vars;
      string body =
         "This is a body that is intended to test really long lines. A body "
         "containing a line that is over 1000 characters is not permitted when "
         "using SMTP unless the body is transfer-encoded. This particular "
         "body should be transfer-encoded using base64. This body has no line "
         "breaks whatsoever and is more than 1000 characters long. It ends with "
         "a whole bunch of the letter Z's. Like it's sleeping. Here come the "
         "Z's ... there are 1000 of them: ";
      body.append(1000, 'Z');
      body.append(". Thus ends the Z's and this body.");
      vars["body"] = body.c_str();

      // parse mail
      monarch::mail::Mail mail;
      parser.parse(&mail, vars, false, &bais);

      // set url of mail server
      Url url(VALID_SMTP_SERVER);

      // send mail
      monarch::mail::SmtpClient c;
      c.sendMail(&url, &mail);
   }
   tr.passIfNoException();

   tr.test("body with CRLF");
   {
      const char* body =
         "Transaction ID : 2009070000000000191\r\n"
         "Date           : Tue, 20 Jan 2009 18:39:36\r\n"
         "License Amount : $0.8000000\r\n"
         "================================ Request ===================================\n"
         "whatever\n"
         "================================ Contract ==================================\n"
         "whatever\n";

      // create mail template
      const char* tpl =
         "MIME-Version: 1.0\r\n"
         "Content-Transfer-Encoding: base64\r\n"
         "Subject: This is an autogenerated unit test MIME email with CRLF'd body\r\n"
         "From: testuser@bitmunk.com\r\n"
         "To: support@bitmunk.com\r\n"
         "\r\n"
         "{body}";

      // create template parser
      monarch::mail::MailTemplateParser parser;

      // create input stream
      ByteArrayInputStream bais(tpl, strlen(tpl));

      // create variables
      DynamicObject vars;
      vars["body"] = body;

      // parse mail
      monarch::mail::Mail mail;
      parser.parse(&mail, vars, false, &bais);

      // set url of mail server
      Url url(VALID_SMTP_SERVER);

      // send mail
      monarch::mail::SmtpClient c;
      c.sendMail(&url, &mail);
   }
   tr.passIfNoException();
}

void runMailTemplateParser(TestRunner& tr)
{
   tr.test("MailTemplateParser");

   // create mail template
   const char* tpl =
      "Subject: This is an autogenerated unit test email\r\n"
      "From: testuser@bitmunk.com\r\n"
      "To: support@bitmunk.com\r\n"
      "Cc: support@bitmunk.com\r\n"
      "Bcc: {bccAddress1}\r\n"
      "\r\n"
      "This is the test body. I want $10.00.\n"
      "I used a variable: {:ldelim}bccAddress1{:rdelim} with the value of "
      "'{bccAddress1}'.\n"
      "Slash before variable \\{bccAddress1}.\n"
      "2 slashes before variable \\\\{bccAddress1}.\n"
      "Slash before escaped variable \\{:ldelim}bccAddress1{:rdelim}.\n"
      "2 slashes before escaped variable \\\\{:ldelim}bccAddress1{:rdelim}.\n"
      "{eggs}{bacon}{ham}{sausage}.";

   // create template parser
   monarch::mail::MailTemplateParser parser;

   // create input stream
   ByteArrayInputStream bais(tpl, strlen(tpl));

   // create variables
   DynamicObject vars;
   vars["bccAddress1"] = "support@bitmunk.com";
   vars["eggs"] = "This is a ";
   //vars["bacon"] -- no bacon
   vars["ham"] = "number ";
   vars["sausage"] = 5;

   // parse mail
   monarch::mail::Mail mail;
   parser.parse(&mail, vars, false, &bais);

   const char* expect =
      "This is the test body. I want $10.00.\r\n"
      "I used a variable: {bccAddress1} with the value of "
      "'support@bitmunk.com'.\r\n"
      "Slash before variable \\support@bitmunk.com.\r\n"
      "2 slashes before variable \\\\support@bitmunk.com.\r\n"
      "Slash before escaped variable \\{bccAddress1}.\r\n"
      "2 slashes before escaped variable \\\\{bccAddress1}.\r\n"
      "This is a number 5.\r\n";

   // get mail message
   monarch::mail::Message msg = mail.getMessage();

   // assert body parsed properly
   const char* body = msg["body"]->getString();
   assertStrCmp(body, expect);

   // create template from mail
   string generatedTemplate = mail.toTemplate();

   const char* genExpect =
      "CC: support@bitmunk.com\r\n"
      "From: testuser@bitmunk.com\r\n"
      "Subject: This is an autogenerated unit test email\r\n"
      "To: support@bitmunk.com\r\n"
      "\r\n"
      "This is the test body. I want $10.00.\r\n"
      "I used a variable: {:ldelim}bccAddress1{:rdelim} with the value "
      "of 'support@bitmunk.com'.\r\n"
      "Slash before variable \\support@bitmunk.com.\r\n"
      "2 slashes before variable \\\\support@bitmunk.com.\r\n"
      "Slash before escaped variable \\{:ldelim}bccAddress1{:rdelim}.\r\n"
      "2 slashes before escaped variable \\\\{:ldelim}bccAddress1{:rdelim}.\r\n"
      "This is a number 5.\r\n";

   assertStrCmp(generatedTemplate.c_str(), genExpect);
   //printf("Generated template=%s\n", generatedTemplate.c_str());

//   // print out mail message
//   printf("\nHeaders=\n");
//   DynamicObjectIterator i = msg["headers"].getIterator();
//   while(i->hasNext())
//   {
//      DynamicObject header = i->next();
//      DynamicObjectIterator doi = header.getIterator();
//      while(doi->hasNext())
//      {
//         printf("%s: %s\n", i->getName(), doi->next()->getString());
//      }
//   }
//
//   printf("Expect=%s\n", expect);
//   printf("Body=%s\n", msg["body"]->getString());

//   // set url of mail server
//   Url url(VALID_SMTP_SERVER);
//
//   // send mail
//   monarch::mail::SmtpClient c;
//   c.sendMail(&url, &mail);

   tr.passIfNoException();
}

static void _runMailboxTest(
   TestRunner& tr, const char* address, const char* domain, const char* smtp)
{
   const int buflen = 1000;
   char buf[buflen];

   snprintf(buf, 256, "Mailbox(%s)", address);

   tr.test(buf);

   // simple mail template
   const char* tpl = "To: %s\r\n";
   bool success;

   // create template parser
   monarch::mail::MailTemplateParser parser;

   // create test
   snprintf(buf, buflen, tpl, address);

   // create input stream
   ByteArrayInputStream bais(buf, strlen(buf));

   // create variables
   DynamicObject vars;
   vars->setType(Map);

   // parse mail
   monarch::mail::Mail mail;
   success = parser.parse(&mail, vars, false, &bais);
   assertNoException();
   assert(success);

   monarch::mail::AddressList expect;
   monarch::mail::Address addr = expect->append();
   addr["address"] = address;
   addr["domain"] = domain;
   addr["smtpEncoding"] = smtp;

   // get parsed recipients
   monarch::mail::AddressList alist = mail.getRecipients();

   assertNamedDynoCmp("AddressList", alist, "Expect", expect);

   tr.passIfNoException();
}

void runMailboxTest(TestRunner& tr)
{
   tr.group("Mailbox");

   // Check various forms of address parsing:
   //  user@example.com
   //  <user@example.com>
   //  User <user@example.com>
   //  "Example User" <user@example.com>

   _runMailboxTest(
      tr, "user@example.com", "example.com", "<user@example.com>");
   _runMailboxTest(
      tr, "<user@example.com>", "example.com", "<user@example.com>");
   _runMailboxTest(
      tr, "User <user@example.com>", "example.com", "<user@example.com>");
   _runMailboxTest(
      tr, "\"Example User\" <user@example.com>", "example.com",
      "<user@example.com>");
   _runMailboxTest(
      tr, "\"<Example User>\" <user@example.com>", "example.com",
      "<user@example.com>");

   tr.ungroup();
}

void mailSpoolTest(TestRunner& tr)
{
   tr.test("MailSpool");

   // create mail template
   const char* tpl =
      "Subject: This is an autogenerated unit test email\r\n"
      "From: testuser@bitmunk.com\r\n"
      "To: support@bitmunk.com\r\n"
      "Cc: support@bitmunk.com\r\n"
      "Bcc: {bccAddress1}\r\n"
      "\r\n"
      "This is the test body. I want $10.00.\n"
      "I used a variable: {:ldelim}bccAddress1{:rdelim} with the value "
      "of '{bccAddress1}'.\r\n"
      "Slash before variable \\{bccAddress1}.\r\n"
      "2 slashes before variable \\\\{bccAddress1}.\r\n"
      "Slash before escaped variable \\{:ldelim}bccAddress1{:rdelim}.\r\n"
      "2 slashes before escaped variable \\\\{:ldelim}bccAddress1{:rdelim}.\r\n"
      "{eggs}{bacon}{ham}{sausage}.";

   // create template parser
   monarch::mail::MailTemplateParser parser;

   // create input stream
   ByteArrayInputStream bais(tpl, strlen(tpl));

   // create variables
   DynamicObject vars;
   vars["bccAddress1"] = "support@bitmunk.com";
   vars["eggs"] = "This is a ";
   vars["bacon"] = ""; // -- no bacon
   vars["ham"] = "number ";
   vars["sausage"] = 5;

   // parse mail
   monarch::mail::Mail mail;
   parser.parse(&mail, vars, true, &bais);

   // get template
   string tpl1 = mail.toTemplate();

   // get new tmp spool file
   File file = File::createTempFile("spool");

   // create mail spool
   monarch::mail::MailSpool spool;
   string spoolUrl = "file://";
   spoolUrl.append(file->getAbsolutePath());
   StringTools::replaceAll(spoolUrl, "\\", "/");
   spool.initialize(spoolUrl.c_str());
   assertNoException();

   DynamicObject reason;
   reason = "could not send";

   // spool mail
   spool.spool(&mail, &reason);
   assertNoException();

   // spool mail
   spool.spool(&mail, &reason);
   assertNoException();

   // spool mail
   spool.spool(&mail, &reason);
   assertNoException();

   // get mail
   monarch::mail::Mail m2;
   spool.getFirst(&m2);
   assertNoException();

   // assert templates are equal
   string tpl2 = m2.toTemplate();
   assertStrCmp(tpl1.c_str(), tpl2.c_str());

   // unwind
   spool.unwind();
   spool.unwind();
   assertNoException();

   // get mail
   monarch::mail::Mail m3;
   spool.getFirst(&m3);
   assertNoException();

   // assert templates are equal
   string tpl3 = m3.toTemplate();
   assertStrCmp(tpl1.c_str(), tpl3.c_str());

   // unwind
   spool.unwind();

   // get first mail (should exception, spool is empty)
   spool.getFirst(&m3);
   assertException();
   Exception::clear();

   tr.passIfNoException();
}

void runFailedMailSendTest(TestRunner& tr)
{
   tr.test("FailedMailSend");

   // set url of bogus mail server
   Url url("smtp://localhost:66000");

   // set mail
   monarch::mail::Mail mail;
   mail.setSender("testuser@bitmunk.com");
   mail.addTo("support@bitmunk.com");
   mail.addCc("support@bitmunk.com");
   mail.setSubject("This is an autogenerated unit test email");
   mail.setBody("This is the test body");

   // create spool to store failed send
   monarch::mail::MailSpool spool;
   File file = File::createTempFile("spool");
   string spoolUrl = "file://";
   spoolUrl.append(file->getAbsolutePath());
   StringTools::replaceAll(spoolUrl, "\\", "/");
   spool.initialize(spoolUrl.c_str());

   // send mail
   monarch::mail::SmtpClient c;
   bool sent = c.sendMail(&url, &mail);
   assert(!sent);
   if(!sent)
   {
      // check for network errors, we want to spool the mail
      ExceptionRef e = Exception::get();
      if(!e->getCauseOfType("monarch.net", true).isNull())
      {
         DynamicObject reason = Exception::getAsDynamicObject();
         Exception::clear();
         spool.spool(&mail, &reason);
         assertNoException();

         // now send the mail properly
         monarch::mail::Mail mail2;
         spool.getFirst(&mail2);
         assertNoException();
         spool.unwind();
         assertNoException();
         url.setUrl(VALID_SMTP_SERVER);
         c.sendMail(&url, &mail2);
         assertNoException();
      }
   }

   tr.passIfNoException();
}

class MoMailTester : public monarch::test::Tester
{
public:
   MoMailTester()
   {
      setName("mail");
   }

   /**
    * Run automatic unit tests.
    */
   virtual int runAutomaticTests(TestRunner& tr)
   {
      runMailTemplateParser(tr);
      runMailboxTest(tr);
      mailSpoolTest(tr);
      return 0;
   }

   /**
    * Runs interactive unit tests.
    */
   virtual int runInteractiveTests(TestRunner& tr)
   {
      //runSmtpClientTest(tr);
      //runMimeTest(tr);
      runFailedMailSendTest(tr);
      return 0;
   }
};

monarch::test::Tester* getMoMailTester() { return new MoMailTester(); }


MO_TEST_MAIN(MoMailTester)
