/*
 * Copyright (c) 2007-2011 Digital Bazaar, Inc. All rights reserved.
 */
#define __STDC_CONSTANT_MACROS

#include <cstdio>

#include "monarch/test/Test.h"
#include "monarch/test/TestModule.h"
#include "monarch/io/ByteArrayInputStream.h"
#include "monarch/io/ByteArrayOutputStream.h"
#include "monarch/io/File.h"
#include "monarch/io/FileOutputStream.h"
#include "monarch/data/TemplateInputStream.h"
#include "monarch/data/json/JsonWriter.h"
#include "monarch/logging/Logging.h"

using namespace std;
using namespace monarch::test;
using namespace monarch::data;
using namespace monarch::data::json;
using namespace monarch::io;
using namespace monarch::rt;

namespace mo_test_template
{

/**
 * Check for expected template output. Can pass NULL for expect to skip
 * checking for valid output which is useful to check for template
 * processing exceptions.
 *
 * @param tpl the template string.
 * @param vars the vars to use during template processing.
 * @param expect the expected output string or NULL to not check.
 */
static void assertTplCmp(
   const char* tpl, DynamicObject& vars, const char* expect, bool strict)
{
   // create template input stream
   ByteArrayInputStream bais(tpl, strlen(tpl));
   TemplateInputStream tis(vars, strict, &bais, false);

   // parse entire template
   ByteBuffer output(2048);
   ByteArrayOutputStream baos(&output, true);
   tis.parse(&baos);

   if(expect != NULL)
   {
      assertNoExceptionSet();

      // null-terminate output
      output.putByte(0, 1, true);

      // assert expected value
      assertNamedStrCmp("expect", expect, "output", output.data());
   }
}

static void runTemplateInputStreamTest(TestRunner& tr)
{
   tr.group("TemplateInputStream");

   tr.test("parse (valid)");
   {
      const char* tpl =
         "Subject: This is an autogenerated unit test email\r\n"
         "From: testuser@bitmunk.com\r\n"
         "To: support@bitmunk.com\r\n"
         "Cc: support@bitmunk.com\r\n"
         "{*singlelinecomment*}"
         "{* another comment *}"
         "Bcc: {bccAddress1}\r\n"
         "\r\n"
         "This is the test body. I want $10.00.\n"
         "I used a variable: {:ldelim}bccAddress1{:rdelim}"
         " with the value of '{bccAddress1}'.\n"
         "Slash before variable \\{bccAddress1}.\n"
         "2 slashes before variable \\\\{bccAddress1}.\n"
         "Slash before escaped variable \\{:ldelim}bccAddress1{:rdelim}.\n"
         "2 slashes before escaped variable "
         "\\\\{:literal}{bccAddress1}{:end}.\n"
         "{eggs}{bacon}{ham|capitalize}{sausage}.\n"
         "{* This is a multiple line comment \n"
         "  {foo} that should not show \\up at all }\n"
         "*}";

      DynamicObject vars;
      vars["bccAddress1"] = "support@bitmunk.com";
      vars["eggs"] = "This is a ";
      // vars["bacon"] -- no bacon
      vars["ham"] = "number ";
      vars["sausage"] = 5;

      const char* expect =
         "Subject: This is an autogenerated unit test email\r\n"
         "From: testuser@bitmunk.com\r\n"
         "To: support@bitmunk.com\r\n"
         "Cc: support@bitmunk.com\r\n"
         "Bcc: support@bitmunk.com\r\n"
         "\r\n"
         "This is the test body. I want $10.00.\n"
         "I used a variable: {bccAddress1} with the value of "
         "'support@bitmunk.com'.\n"
         "Slash before variable \\support@bitmunk.com.\n"
         "2 slashes before variable \\\\support@bitmunk.com.\n"
         "Slash before escaped variable \\{bccAddress1}.\n"
         "2 slashes before escaped variable \\\\{bccAddress1}.\n"
         "This is a Number 5.\n";

      assertTplCmp(tpl, vars, expect, false);
   }
   tr.passIfNoException();

   tr.test("parse (DOS paths)");
   {
      const char* tpl =
         "The path is {PATH}!";

      DynamicObject vars;
      vars["PATH"] = "C:\\Dox";

      const char* expect =
         "The path is C:\\Dox!";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (DOS paths in template)");
   {
      const char* tpl =
         "The path is C:\\Dox!";

      DynamicObject vars;

      const char* expect =
         "The path is C:\\Dox!";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (invalid - ends in '{')");
   {
      const char* tpl =
         "This template ends in an escape character{";

      DynamicObject vars;
      vars["bccAddress1"] = "support@bitmunk.com";
      vars["eggs"] = "This is a ";
      vars["bacon"] = ""; // -- no bacon
      vars["ham"] = "number ";
      vars["sausage"] = 5;

      assertTplCmp(tpl, vars, NULL, true);
   }
   tr.passIfException();

   tr.test("parse (invalid - missing variable)");
   {
      const char* tpl = "{a}{b}";

      // create variable "a" and omit "b"
      DynamicObject vars;
      vars["a"] = "A!";

      assertTplCmp(tpl, vars, NULL, true);
   }
   tr.passIfException();

   tr.test("parse (invalid - incomplete markup)");
   {
      const char* tpl =
         "{eggs}{bacon}{ham}{sausage}{incompleteMarkup";

      DynamicObject vars;
      vars["eggs"] = "This is a ";
      vars["bacon"] = ""; // -- no bacon
      vars["ham"] = "number ";
      vars["sausage"] = 5;

      assertTplCmp(tpl, vars, NULL, true);
   }
   tr.passIfException();

   tr.test("parse (reuse pipeline)");
   {
      // create template
      const char* tpl1 = "{TEST1}";

      // create variables
      DynamicObject vars;
      vars["TEST1"] = "111";
      vars["TEST2"] = "222";

      // create template input stream
      ByteArrayInputStream bais(tpl1, strlen(tpl1));
      TemplateInputStream tis(vars, false, &bais, false);

      // parse entire template
      ByteBuffer output(2048);
      ByteArrayOutputStream baos(&output, true);
      tis.parse(&baos);

      // null-terminate output
      output.putByte(0, 1, true);

      // assert expected value
      assertStrCmp("111", output.data());

      const char* tpl2 = "{TEST2}";
      bais.setByteArray(tpl2, strlen(tpl2));
      output.clear();
      tis.setInputStream(&bais, false);
      tis.parse(&baos);
      output.putByte(0, 1, true);

      // assert expected value
      assertStrCmp("222", output.data());
   }
   tr.passIfNoException();

   tr.test("parse (map)");
   {
      const char* tpl =
         "The number five: {foo.five[1]}\n"
         "{:each from=foo.items as=item key=key}\n"
         "The item is '{item}', key is '{key}'\n"
         "{:end}";

      DynamicObject vars;
      vars["foo"]["items"]->append("item1");
      vars["foo"]["items"]->append("item2");
      vars["foo"]["items"]->append("item3");
      vars["foo"]["five"]->append(4);
      vars["foo"]["five"]->append(5);

      const char* expect =
         "The number five: 5\n"
         "The item is 'item1', key is '0'\n"
         "The item is 'item2', key is '1'\n"
         "The item is 'item3', key is '2'\n";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (each)");
   {
      const char* tpl =
         "Item count: {items.length}\n"
         "{:each from=items as=item key=key}\n"
         "The item is '{item}', key is '{key}'\n"
         "{:end}";

      DynamicObject vars;
      vars["items"]["a"] = "item1";
      vars["items"]["b"] = "item2";
      vars["items"]["c"] = "item3";

      const char* expect =
         "Item count: 3\n"
         "The item is 'item1', key is 'a'\n"
         "The item is 'item2', key is 'b'\n"
         "The item is 'item3', key is 'c'\n";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (eachelse)");
   {
      const char* tpl =
         "Item count: {items.length}\n"
         "{:each from=items as=item key=key}\n"
         "The item is '{item}', key is '{key}'\n"
         "{:eachelse}\n"
         "There are no items.\n"
         "{:end}\n"
         "{:set items.a='item1'}\n"
         "Item count: {items.length}\n"
         "{:each from=items as=item key=key}\n"
         "The item is '{item}', key is '{key}'\n"
         "{:eachelse}\n"
         "There are no items.\n"
         "{:end}";

      DynamicObject vars;
      vars["items"]->setType(Array);

      const char* expect =
         "Item count: 0\n"
         "There are no items.\n"
         "Item count: 1\n"
         "The item is 'item1', key is 'a'\n";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (invalid - each)");
   {
      const char* tpl =
         "{:each from=items as=item}\n"
         "The item is '{item}'\n";

      DynamicObject vars;
      vars["items"]->append("item1");
      vars["items"]->append("item2");
      vars["items"]->append("item3");

      assertTplCmp(tpl, vars, NULL, true);
   }
   tr.passIfException();

   tr.test("parse (empty each)");
   {
      const char* tpl =
         "Items:\n"
         "{:each from=items as=item}\n"
         "The item is '{item}'\n"
         "{:end}\n"
         "{:if end}\nend{:end}\n";

      DynamicObject vars;
      vars["items"]->setType(Array);
      vars["end"] = true;

      const char* expect =
         "Items:\n"
         "end";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (loop)");
   {
      const char* tpl =
         "Item count: {items.length}\n"
         "{:loop start=0 until=items.length index=current}\n"
         "The item is '{items[current]}', index is {current}\n"
         "{:end}";

      DynamicObject vars;
      vars["items"]->append("item1");
      vars["items"]->append("item2");
      vars["items"]->append("item3");

      const char* expect =
         "Item count: 3\n"
         "The item is 'item1', index is 0\n"
         "The item is 'item2', index is 1\n"
         "The item is 'item3', index is 2\n";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (loopelse)");
   {
      const char* tpl =
         "Item count: {items.length}\n"
         "{:loop start=0 until=items.length index=current}\n"
         "The item is '{items[current]}', index is {current}\n"
         "{:loopelse}\n"
         "There are no items.\n"
         "{:end}\n"
         "{:set items[0]='item1'}\n"
         "Item count: {items.length}\n"
         "{:loop start=0 until=items.length index=current}\n"
         "The item is '{items[current]}', index is {current}\n"
         "{:loopelse}\n"
         "There are no items.\n"
         "{:end}";

      DynamicObject vars;
      vars["items"]->setType(Array);

      const char* expect =
         "Item count: 0\n"
         "There are no items.\n"
         "Item count: 1\n"
         "The item is 'item1', index is 0\n";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (invalid - loop)");
   {
      const char* tpl =
         "{:loop start=0 until=items.length}\n"
         "The item is '{items[current]}'\n";

      DynamicObject vars;
      vars["items"]->append("item1");
      vars["items"]->append("item2");
      vars["items"]->append("item3");

      assertTplCmp(tpl, vars, NULL, true);
   }
   tr.passIfException();

   tr.test("parse (empty loop)");
   {
      const char* tpl =
         "Items:\n"
         "{:loop start=0 until=items.length index=current}\n"
         "The item is '{items[current]}'\n"
         "{:end}\n"
         "{:if end}\nend{:end}\n";

      DynamicObject vars;
      vars["items"]->setType(Array);
      vars["end"] = true;

      const char* expect =
         "Items:\n"
         "end";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (include)");
   {
      // write out template
      File file = File::createTempFile("test");
      FileOutputStream fos(file);
      const char* include =
         "{:each from=items as=item}"
         "The item is '{item}'\n"
         "{:end}";
      fos.write(include, strlen(include));
      fos.close();
      assertNoExceptionSet();

      const char* tpl =
         "Items:\n"
         "{:include file=myfile}\n"
         "Again:\n"
         "{:include file=myfile as=foo}"
         "{foo}";

      DynamicObject vars;
      vars["items"]->append("item1");
      vars["items"]->append("item2");
      vars["items"]->append("item3");
      vars["myfile"] = file->getAbsolutePath();

      const char* expect =
         "Items:\n"
         "The item is 'item1'\n"
         "The item is 'item2'\n"
         "The item is 'item3'\n"
         "Again:\n"
         "The item is 'item1'\n"
         "The item is 'item2'\n"
         "The item is 'item3'\n";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (cascaded include)");
   {
      // write out template 1
      File file1 = File::createTempFile("test");
      {
         FileOutputStream fos(file1);
         const char* include =
            "{:each from=items as=item}"
            "The item is '{item}'\n"
            "{:end}";
         fos.write(include, strlen(include));
         fos.close();
         assertNoExceptionSet();
      }

      // write out template 2
      File file2 = File::createTempFile("test");
      {
         FileOutputStream fos(file2);
         const char* path = file1->getAbsolutePath();
         int len = 100 + strlen(path);
         char tpl[len + 1];
         snprintf(tpl, len,
            "Items:\n"
            "{:include file='%s'}", path);
         fos.write(tpl, strlen(tpl));
         fos.close();
         assertNoExceptionSet();
      }

      // create template
      const char* path = file2->getAbsolutePath();
      int len = 100 + strlen(path);
      char tpl[len + 1];
      snprintf(tpl, len,
         "Double include:\n"
         "{:include file='%s'}", path);

      DynamicObject vars;
      vars["items"]->append("item1");
      vars["items"]->append("item2");
      vars["items"]->append("item3");

      const char* expect =
         "Double include:\n"
         "Items:\n"
         "The item is 'item1'\n"
         "The item is 'item2'\n"
         "The item is 'item3'\n";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (include w/cache)");
   {
      TemplateCache cache;

      // write out template
      File file = File::createTempFile("test");
      FileOutputStream fos(file);
      const char* include =
         "{:each from=items as=item}"
         "The item is '{item}'\n"
         "{:end}";
      fos.write(include, strlen(include));
      fos.close();
      assertNoExceptionSet();

      const char* tpl =
         "Items:\n"
         "{:include file=myfile}"
         "Again:\n"
         "{:include file=myfile as=foo}"
         "{foo}";

      DynamicObject vars;
      vars["items"]->append("item1");
      vars["items"]->append("item2");
      vars["items"]->append("item3");
      vars["myfile"] = file->getAbsolutePath();

      const char* expect =
         "Items:\n"
         "The item is 'item1'\n"
         "The item is 'item2'\n"
         "The item is 'item3'\n"
         "Again:\n"
         "The item is 'item1'\n"
         "The item is 'item2'\n"
         "The item is 'item3'\n";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (if)");
   {
      const char* tpl =
         "{:each from=foo.items as=item index=index}"
         "{:if bar}{bar}{:end}"
         "{:if item == 'item1'}"
         "The item is '{item}'\n"
         "{:set found=index}"
         "{:end}"
         "{:end}"
         "{:if found == foo.special-1}"
         "The item is special\n"
         "{:end}";

      DynamicObject vars;
      vars["foo"]["items"]->append("item1");
      vars["foo"]["items"]->append("item2");
      vars["foo"]["items"]->append("item3");
      vars["foo"]["special"] = 1;

      const char* expect =
         "The item is 'item1'\n"
         "The item is special\n";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (if/elseif/else)");
   {
      const char* tpl =
         "{:each from=foo.items as=item}"
         "{:if item == 'item1'}"
         "The first item is '{item}'\n"
         "{:elseif item == 2}"
         "The second item is '{item}'\n"
         "{:elseif item == foo.third}"
         "The third item is a secret\n"
         "{:elseif item < 5}"
         "The fourth item is '{item}'\n"
         "{:else}"
         "The fifth item is '{item}'\n"
         "{:end}"
         "{:end}";

      DynamicObject vars;
      vars["foo"]["items"]->append("item1");
      vars["foo"]["items"]->append(2);
      vars["foo"]["items"]->append("secret");
      vars["foo"]["items"]->append(4);
      vars["foo"]["items"]->append("item5");
      vars["foo"]["third"] = "secret";

      const char* expect =
         "The first item is 'item1'\n"
         "The second item is '2'\n"
         "The third item is a secret\n"
         "The fourth item is '4'\n"
         "The fifth item is 'item5'\n";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (pipe)");
   {
      const char* tpl =
         "Item count: {items.length}\n"
         "{:each from=items as=item key=key}"
         "The item is '{item|escape|escape('url')}', "
         "capitalized key is '{key|capitalize}'\n"
         "{:end}"
         "Replaced 'c' in '{cat}' with a 'br': {cat|replace('c','br')}\n"
         "Regex replaced '{foobar}' with '"
         "{foobar|regex('o\\{2\\}','oot')}'\n"
         "Default (undefined): {undefined|default('N/A')}\n"
         "Default (empty string): {empty|default('N/A')}\n"
         "<html><body>{eol|replace('\n','</br>')}</body></html>\n"
         "{escapeQuotes|replace('\\'','\\\\\\'')}\n"
         "Truncated 'foobar' to '{foobar|truncate(3)}'\n"
         "Truncated 'foobar' to '{foobar|truncate(3,'')}'\n";

      DynamicObject vars;
      vars["items"]["apple"] = "item&1";
      vars["items"]["banana"] = "item&2";
      vars["items"]["cherry"] = "item&3";
      vars["cat"] = "cat";
      vars["foobar"] = "foobar";
      vars["empty"] = "";
      vars["eol"] = "none\n";
      vars["escapeQuotes"] = "Jimmy's Chicken Shack";

      const char* expect =
         "Item count: 3\n"
         "The item is 'item%26amp%3B1', capitalized key is 'Apple'\n"
         "The item is 'item%26amp%3B2', capitalized key is 'Banana'\n"
         "The item is 'item%26amp%3B3', capitalized key is 'Cherry'\n"
         "Replaced 'c' in 'cat' with a 'br': brat\n"
         "Regex replaced 'foobar' with 'footbar'\n"
         "Default (undefined): N/A\n"
         "Default (empty string): N/A\n"
         "<html><body>none</br></body></html>\n"
         "Jimmy\\'s Chicken Shack\n"
         "Truncated 'foobar' to '...'\n"
         "Truncated 'foobar' to 'foo'\n";

      assertTplCmp(tpl, vars, expect, false);
   }
   tr.passIfNoException();

   tr.test("parse (invalid pipe)");
   {
      const char* tpl =
         "Item count: {items.length}\n"
         "{:each from=items as=item key=key}"
         "The item is '{item|unknown}', key is '{key}'\n"
         "{:end}";

      DynamicObject vars;
      vars["items"]["a"] = "item1";
      vars["items"]["b"] = "item2";
      vars["items"]["c"] = "item3";

      assertTplCmp(tpl, vars, NULL, true);
   }
   tr.passIfException();

   tr.test("parse (set/unset)");
   {
      const char* tpl =
         "{:if foo}"
            "bar was {bar}\n"
            "{:set bar='some text'}"
            "bar is now '{bar}'\n"
            "{:set mymap.foo=bar}"
            "mymap.foo is now '{mymap.foo}'\n"
            "{:unset bar}"
            "bar is back to {bar}\n"
            "mymap.foo is still '{mymap.foo}'\n"
            "{:set bar=true}"
            "{:if bar == true}"
               "{:set mymap.foo=bar}"
               "mymap.foo is now {mymap.foo}\n"
               "{:set mymap.foo[0]='in an array'}"
               "mymap.foo[0] is '{mymap.foo[0]}'\n"
               "{:unset mymap}"
               "{:set mynumber=17}"
               "mynumber is {mynumber}\n"
               "{:set mynumber=mynumber+1}"
               "mynumber incremented to {mynumber}\n"
               "{:set mynumber=mynumber-2}"
               "mynumber decremented to {mynumber}\n"
            "{:end}"
         "{:end}";

      DynamicObject vars;
      vars["foo"] = true;
      vars["bar"] = 12;

      const char* expect =
         "bar was 12\n"
         "bar is now 'some text'\n"
         "mymap.foo is now 'some text'\n"
         "bar is back to 12\n"
         "mymap.foo is still 'some text'\n"
         "mymap.foo is now true\n"
         "mymap.foo[0] is 'in an array'\n"
         "mynumber is 17\n"
         "mynumber incremented to 18\n"
         "mynumber decremented to 16\n";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (each, set local)");
   {
      const char* tpl =
         "{:each from=objs as=obj}"
         "   {:set obj=obj}"
         "{:end}";

      DynamicObject vars;
      vars["objs"][0] = "0";
      vars["objs"][1] = "1";

      // just checking for no exceptions, no interesting output.
      assertTplCmp(tpl, vars, NULL, true);
   }
   tr.passIfNoException();

   tr.test("parse (dump)");
   {
      const char* tpl =
         "{:set foo='A'}"
         "{:dump foo}\n"
         "\n"
         "{foo|json}\n"
         "{:set bar='B'}"
         "{:dump}";

      DynamicObject vars;
      vars["foobar"] = "C";

      // create expected string
      DynamicObject expectVars;
      expectVars["localVars"]["foo"] = "A";
      expectVars["localVars"]["bar"] = "B";
      expectVars["vars"]["foobar"] = "C";
      string expect =
         "\"A\"\n"
         "\"A\"\n";
      expect.append(JsonWriter::writeToString(expectVars, false, false));

      assertTplCmp(tpl, vars, expect.c_str(), true);
   }
   tr.passIfNoException();

   tr.test("parse (date pipe)");
   {
      const char* tpl =
         "{mydate|date('%Y-%m-%d')}\n"
         "{mydate|date('%Y-%m-%d','',0,0)}\n"
         "{longdate|date('%Y-%m-%d','%a, %d %b %Y %H:%M:%S')}\n"
         "{longdate|date('%Y-%m-%d','%a, %d %b %Y %H:%M:%S','UTC')}\n"
         "{longdate|date('%Y-%m-%d','%a, %d %b %Y %H:%M:%S','','')}\n"
         "{longdate|date('%Y-%m-%d %H:%M:%S','%a, %d %b %Y %H:%M:%S','','')}\n"
         "{longdate|date('%Y-%m-%d %H:%M:%S','%a, %d %b %Y %H:%M:%S',0,60)}\n"
         "{longdate|date('%Y-%m-%d %H:%M:%S','%a, %d %b %Y %H:%M:%S',0,-60)}\n";

      DynamicObject vars;
      vars["mydate"] = "2010-01-01 00:01:00";
      vars["longdate"] = "Sat, 21 Jan 2006 03:15:46";

      const char* expect =
         "2010-01-01\n"
         "2010-01-01\n"
         "2006-01-21\n"
         "2006-01-21\n"
         "2006-01-21\n"
         "2006-01-21 03:15:46\n"
         "2006-01-21 02:15:46\n"
         "2006-01-21 04:15:46\n";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (date pipe timezones)");
   {
      const char* tpl =
         "{dz|date(tout,tin,0,tz)}\n"
         "{d0|date(tout,tin,0,tz)}\n"
         "{d1|date(tout,tin,0,tz)}\n"
         "{d2|date(tout,tin,0,tz)}\n";

      DynamicObject vars;
      vars["tin"] = "%Y-%m-%dT%H:%M:%S%Z";
      vars["tout"] = "%Y-%m-%dT%H:%M:%S%z";
      vars["tz"] = "GMT";

      vars["dz"] = "2010-01-01T06:01:01Z";
      vars["d0"] = "2010-01-01T06:01:01+00:00";
      vars["d1"] = "2010-01-01T06:01:01+01:00";
      vars["d2"] = "2010-01-01T06:01:01+0100";

      const char* expect =
         "2010-01-01T06:01:01+0000\n"
         "2010-01-01T06:01:01+0000\n"
         "2010-01-01T06:01:01+0000\n"
         "2010-01-01T06:01:01+0000\n";

      tr.warning("Date timezone parsing problems ignored.");
      // FIXME: strptime is parsing but ignoring the tz value?
      /*
      const char* expect =
         "2010-01-01T06:01:01+0000\n"
         "2010-01-01T06:01:01+0000\n"
         "2010-01-01T05:01:01+0000\n"
         "2010-01-01T05:01:01+0000\n";
      */

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (format pipe)");
   {
      const char* tpl =
         "{amount1|format('%1.2f')}\n"
         "{amount2|format('%i')}\n"
         "{amount2|format('%x')}\n"
         "{amount2|format('%X')}\n";

      DynamicObject vars;
      vars["amount1"] = "8234.125";
      vars["amount2"] = "255";

      const char* expect =
         "8234.12\n"
         "255\n"
         "ff\n"
         "FF\n";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (decimal pipe)");
   {
      const char* tpl =
         "${money1|decimal('2')}\n"
         "${money1|decimal('2','up')}\n"
         "${money1|decimal('2','down')}\n"
         "${money2|decimal('2')}\n"
         "${money2|decimal('2','up')}\n"
         "${money2|decimal('2','down')}\n"
         "${cents|decimal('2')}\n"
         "${cents|decimal('2','up')}\n"
         "${cents|decimal('2','down')}\n";

      DynamicObject vars;
      vars["money1"] = "8234.12";
      vars["money2"] = "8234.125";
      vars["cents"] = ".125";

      const char* expect =
         "$8234.12\n"
         "$8234.12\n"
         "$8234.12\n"
         "$8234.13\n"
         "$8234.13\n"
         "$8234.12\n"
         "$0.13\n"
         "$0.13\n"
         "$0.12\n";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (missing map)");
   {
      const char* tpl = "{one.two}";

      DynamicObject vars;
      vars["one"]->setType(Map);

      assertTplCmp(tpl, vars, NULL, true);
   }
   tr.passIfException();

   tr.test("parse (null map)");
   {
      const char* tpl = "{one.two}";

      DynamicObject vars;
      vars["one"].setNull();

      assertTplCmp(tpl, vars, NULL, true);
   }
   tr.passIfException();

   tr.test("parse (null array)");
   {
      const char* tpl = "{one[0]}";

      DynamicObject vars;
      vars["one"].setNull();

      // NOTE: Due to the current design, this test MUST be run in strict
      // mode. Running in non-strict mode will segfault.
      assertTplCmp(tpl, vars, NULL, true);
   }
   tr.passIfException();

   tr.test("parse (string concatenation)");
   {
      const char* tpl =
         "{var+1}\n"
         "{var+'foo'}\n"
         "{var+foo}\n"
         "{var2+'foo'}\n"
         "{var2+foo}\n";

      DynamicObject vars;
      vars["var"] = "start_";
      vars["var2"] = 1;
      vars["foo"] = "bar";

      const char* expect =
         "start_1\n"
         "start_foo\n"
         "start_bar\n"
         "1foo\n"
         "1bar\n";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (escaped operators)");
   {
      const char* tpl =
         "{var\\-1}\n"
         "{var\\+2}\n"
         "{var\\*3}\n"
         "{var\\/4}\n";

      DynamicObject vars;
      vars["var-1"] = "value1";
      vars["var+2"] = "value2";
      vars["var*3"] = "value3";
      vars["var/4"] = "value4";

      const char* expect =
         "value1\n"
         "value2\n"
         "value3\n"
         "value4\n";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (escaped operators after array var)");
   {
      const char* tpl =
         "{var:array[0].foo:bar\\-1}\n"
         "{var:array[0].foo:bar\\-2}\n";

      DynamicObject vars;
      vars["var:array"][0]["foo:bar-1"] = "value1";
      vars["var:array"][0]["foo:bar-2"] = "value2";

      const char* expect =
         "value1\n"
         "value2\n";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (array access on variable with colon)");
   {
      const char* tpl =
         "US ${deposit.ps:payee[0].amount}\n";

      DynamicObject vars;
      vars["deposit"]["ps:payee"][0]["amount"] = "1.00";

      const char* expect =
         "US $1.00\n";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (other array access with index var within each)");
   {
      const char* tpl =
         "{:each from=bar as=item index=idx}{foo[idx].test}{:end}\n";

      DynamicObject vars;
      vars["foo"][0]["test"] = 1;
      vars["bar"][0] = "empty";

      const char* expect =
         "1";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (other 2D array access with index var within each)");
   {
      const char* tpl =
         "{:each from=bar as=item index=idx}"
         "{foo[idx][bar[idx].len]}{:end}\n";

      DynamicObject vars;
      vars["foo"][0][0] = 1;
      vars["bar"][0]["len"] = 0;

      const char* expect =
         "1";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (subtraction w/undefined unstrict lhs)");
   {
      const char* tpl =
         "{foo-bar}\n";

      DynamicObject vars;
      vars["bar"] = 1;

      const char* expect =
         "-1\n";

      assertTplCmp(tpl, vars, expect, false);
   }
   tr.passIfNoException();

   tr.test("parse (subtraction w/undefined unstrict lhs object)");
   {
      const char* tpl =
         "{foo.a-bar}\n";

      DynamicObject vars;
      vars["bar"] = 1;

      const char* expect =
         "-1\n";

      assertTplCmp(tpl, vars, expect, false);
   }
   tr.passIfNoException();

   tr.test("parse (subtraction w/undefined unstrict lhs array)");
   {
      const char* tpl =
         "{foo[0]-bar}\n";

      DynamicObject vars;
      vars["bar"] = 1;

      const char* expect =
         "-1\n";

      assertTplCmp(tpl, vars, expect, false);
   }
   tr.passIfNoException();

   tr.test("parse (divide by 0)");
   {
      const char* tpl =
         "{foo-bar}\n";

      DynamicObject vars;
      vars["foo"] = 1;
      vars["bar"] = 0;

      const char* expect =
         "1\n";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (multi-level variable compare)");
   {
      const char* tpl =
         "{:each from=groups as=group index=gnum}"
            "{:each from=group.mo:data as=data index=dnum}"
               "{:if compare.mo:group}"
                  "{:each from=compare.mo:group as=cGroup}"
                     "{:if cGroup.mo:name == group.mo:name}"
                        "{:if cGroup.mo:data}"
                           "{:each from=cGroup.mo:data as=cData}"
                              "{:if data == cData}"
                                 "{data} == {cData}\n"
                              "{:end}"
                           "{:end}"
                        "{:end}"
                     "{:end}"
                  "{:end}"
               "{:end}"
            "{:end}"
         "{:end}";

      DynamicObject vars;

      DynamicObject& groups = vars["groups"];
      groups->setType(Array);
      DynamicObject group1;
      group1["mo:name"] = "Group 1";
      group1["mo:data"]->setType(Array);
      group1["mo:data"]->append("group_1_data_1");
      groups->append(group1);

      DynamicObject group2;
      group2["mo:name"] = "Group 2";
      group2["mo:data"]->setType(Array);
      group2["mo:data"]->append("group_2_data_1");
      group2["mo:data"]->append("group_2_data_2");
      group2["mo:data"]->append("group_2_data_3");
      groups->append(group2);

      DynamicObject& compare = vars["compare"];
      DynamicObject& cgroups = compare["mo:group"];
      cgroups->setType(Array);
      DynamicObject cgroup1;
      cgroup1["mo:name"] = "Group 1";
      cgroup1["mo:data"]->setType(Array);
      cgroup1["mo:data"]->append("group_1_data_1");
      cgroups->append(cgroup1);

      const char* expect =
         "group_1_data_1 == group_1_data_1\n";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (array access)");
   {
      const char* tpl =
         "Item count: {items.length}\n"
         "{:set items[0]='item1'}"
         "Item count: {items.length}\n"
         "{:set items[1]='item2'}"
         "Item count: {items.length}\n"
         "|{:each from=items as=item}{item}|{:end}\n";

      DynamicObject vars;
      vars["items"]->setType(Array);

      const char* expect =
         "Item count: 0\n"
         "Item count: 1\n"
         "Item count: 2\n"
         "|item1|item2|";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (array append)");
   {
      const char* tpl =
         "Item count: {items.length}\n"
         "{:set items[]='item1'}"
         "Item count: {items.length}\n"
         "{:set items[]='item2'}"
         "Item count: {items.length}\n"
         "|{:each from=items as=item}{item}|{:end}\n";

      DynamicObject vars;
      vars["items"]->setType(Array);

      const char* expect =
         "Item count: 0\n"
         "Item count: 1\n"
         "Item count: 2\n"
         "|item1|item2|";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (undefined member var w/defined same-name global var)");
   {
      const char* tpl =
         "{foo.a}";

      DynamicObject vars;
      vars["a"] = "bar";

      assertTplCmp(tpl, vars, NULL, true);
   }
   tr.passIfException();

   tr.test("parse (variable subtraction from object member)");
   {
      const char* tpl =
         "{foo.a-bar}\n";

      DynamicObject vars;
      vars["foo"]["a"] = 3;
      vars["bar"] = 1;

      const char* expect =
         "2\n";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.test("parse (variable subtraction from array element)");
   {
      const char* tpl =
         "{foo[0]-bar}\n";

      DynamicObject vars;
      vars["foo"][0] = 3;
      vars["bar"] = 1;

      const char* expect =
         "2\n";

      assertTplCmp(tpl, vars, expect, true);
   }
   tr.passIfNoException();

   tr.ungroup();
}

static bool run(TestRunner& tr)
{
   if(tr.isDefaultEnabled() || tr.isTestEnabled("template-input-stream"))
   {
      runTemplateInputStreamTest(tr);
   }
   return true;
}

} // end namespace

MO_TEST_MODULE_FN("monarch.tests.template.test", "1.0", mo_test_template::run)
